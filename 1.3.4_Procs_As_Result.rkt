#lang racket
(require racket/include)
(require  "1.3.3_Procs_As_Generics.rkt")
(require  "1.3.1_Function_As_Args.rkt")
(require  "1.2.4_Power.rkt")
(define (square x) (* x x))
(define dx 0.00001)

(define (average-damp f)(lambda (x) (average x (f x))))
(define (sqrt x)  (fixed-point (average-damp (lambda (y) (/ x y)))1.0))
(define (cube-root x) (fixed-point (average-damp (lambda (y) (/ x (square y)))) 1.0))

;Метод Ньютона

(define (deriv g)(lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))

(define (newton-transform g)(lambda (x)(- x (/ (g x) ((deriv g) x)))))

(define (newtons-method g guess) (fixed-point (newton-transform g) guess))

(define (fixed-point-of-transform g transform guess)(fixed-point (transform g) guess))

(define (sqrt-2 x)(fixed-point-of-transform (lambda (y) (/ x y)) average-damp 1.0))

(define (sqrt-3 x)(fixed-point-of-transform (lambda (y) (- (square y) x)) newton-transform 1.0))


;Упражнение 1.40.
;Определите процедуру cubic, которую можно было бы использовать совместно с процедурой
;newtons-method в выражениях вида
;(newtons-method (cubic a b c) 1)
;для приближенного вычисления нулей кубических уравнений x3 + ax2 + bx + c.
(define (cubic a b c) (lambda (x)(+ (cube x) (* a (square x)) (* b x) c)))
(newtons-method (cubic -10 -10 19) 2)

;Упражнение 1.41.
;Определите процедуру double, которая принимает как аргумент процедуру с одним аргументом и
;возвращает процедуру, которая применяет исходную процедуру дважды. Например, если проце-
;дура inc добавляет к своему аргументу 1, то (double inc) должна быть процедурой, которая
;добавляет 2. Скажите, какое значение возвращает (((double (double double)) inc) 5)
(define (double g) (lambda (x)(g (g x))))
(((double (double double)) inc) 5)

;Упражнение 1.42.
;Пусть f и g — две одноаргументные функции. По определению, композиция (composition) f и
;g есть функция x → f(g(x)). Определите процедуру compose которая реализует композицию.
(define (compose f g) (lambda (x)(f (g x))))
((compose square inc) 6)

;Упражнение 1.43.
;Если f есть численная функция, а n — положительное целое число, то мы можем построить
;n-кратное применение f, которое определяется как функция, значение которой в точке x равно
;f(f(. . . (f(x)) . . .)). Например, если f есть функция x → x + 1, то n-кратным применением f
;будет функция x → x + n. Если f есть операция возведения в квадрат, то n-кратное применение
;f есть функция, которая возводит свой аргумент в 2n-ю степень. Напишите процедуру, которая
;принимает в качестве ввода процедуру, вычисляющую f, и положительное целое n, и возвращает
;процедуру, вычисляющую n-кратное применение f.
(define (repeated f n)
 (if (= n 1)
     f
     (repeated (compose f f) (- n 1))
  )
)
((repeated square 2) 5)

;Упражнение 1.44.
;Идея сглаживания (smoothing a function) играет важную роль в обработке сигналов. Если f —
;функция, а dx — некоторое малое число, то сглаженная версия f есть функция, значение кото-
;рой в точке x есть среднее между f(x - dx), f(x) и f(x + dx). Напишите процедуру smooth,
;которая в качестве ввода принимает процедуру, вычисляющую f, и возвращает процедуру, вы-
;числяющую сглаженную версию f. Иногда бывает удобно проводить повторное сглаживание (то
;есть сглаживать сглаженную функцию и т.д.), получая n-кратно сглаженную функцию (n-fold
;smoothed function). Покажите, как породить n-кратно сглаженную функцию с помощью smooth и
;repeated из упражнения 1.43.
(define (smooth f) (lambda (x) (/ (+ (f x) (f (- x dx)) (f (+ x dx))) 3)))
(define(n-fold-smoothed f n) (repeated (smooth f) n))

;Упражнение 1.45.
;В разделе 1.3.3 мы видели, что попытка вычисления квадратных корней путем наивного поис-
;ка неподвижной точки y → x/y не сходится, и что это можно исправить путем торможения
;усреднением. Тот же самый метод работает для нахождения кубического корня как неподвижной
;точки y → x/y2, заторможенной усреднением. К сожалению, этот процесс не работает для кор-
;ней четвертой степени — однажды примененного торможения усреднением недостаточно, чтобы
;заставить сходиться процесс поиска неподвижной точки y → x/y3. С другой стороны, если мы
;применим торможение усреднением дважды (т.е. применим торможение усреднением к результату
;торможения усреднением от y 7→ x/y3), то поиск неподвижной точки начнет сходиться. Проде-
;лайте эксперименты, чтобы понять, сколько торможений усреднением нужно, чтобы вычислить
;корень n-ой степени как неподвижную точку на основе многократного торможения усреднением
;функции y → x/y^n-1. Используя свои результаты для того, напишите простую процедуру вычис-
;ления корней n-ой степени с помощью процедур fixed-point, average-damp и repeated из
;упражнения 1.43. Считайте, что все арифметические операции, какие Вам понадобятся, присут-
;ствуют в языке как примитивы.
(define (n-root x n) (fixed-point ((repeated average-damp (round (log n 2))) (lambda (y) (/ x (expt y (- n 1))))) 1.0))
;(n-root ( * 256 256 256 256) 32)

;Упражнение 1.46.
;Некоторые из вычислительных методов, описанных в этой главе, являются примерами чрезвычайно
;общей вычислительной стратегии, называемой пошаговое улучшение (iterative improvement). По-
;шаговое улучшение состоит в следующем: чтобы что-то вычислить, нужно взять какое-то началь-
;ное значение, проверить, достаточно ли оно хорошо, чтобы служить ответом, и если нет, то улуч-
;шить это значение и продолжить процесс с новым значением. Напишите процедуру iterative-
;improve, которая принимает в качестве аргументов две процедуры: проверку, достаточно ли хоро-
;шо значение, и метод улучшения значения. Iterative-improve должна возвращать процедуру,
;которая принимает начальное значение в качестве аргумента и улучшает его, пока оно не станет
;достаточно хорошим. Перепишите процедуру sqrt из раздела 1.1.7 и процедуру fixed-point
;из раздела 1.3.3 в терминах iterative-improve.

(define (iterative-improve good-enough? improve)
  (lambda (x)
    (if (good-enough? x)
        x
        ((iterative-improve good-enough? improve) (improve x))
        )
    )
)

(define (sqrt-iter guess value)
  ((iterative-improve (lambda (y) (< (abs (- (square y) value)) 0.0001)) (lambda (y)  (average y (/ value y))))
   guess)
)


(define (fixed-point-iter f first-guess)
  (define (close-enough? v1)
    (< (abs (- v1 (f v1))) tolerance))
  ((iterative-improve close-enough? f) first-guess)
)


(fixed-point cos 1.0)
(fixed-point-iter cos 1.0)
