#lang racket
(define (add-interval x y)
(make-interval (+ (lower-bound x) (lower-bound y))
(+ (upper-bound x) (upper-bound y))))

(define (mul-interval-v0 x y)
(let ((p1 (* (lower-bound x) (lower-bound y)))
(p2 (* (lower-bound x) (upper-bound y)))
(p3 (* (upper-bound x) (lower-bound y)))
(p4 (* (upper-bound x) (upper-bound y))))
(make-interval (min p1 p2 p3 p4)
(max p1 p2 p3 p4))))

(define (div-interval-v0 x y)
(mul-interval-v0 x
(make-interval (/ 1.0 (upper-bound y))
(/ 1.0 (lower-bound y)))))

;Упражнение 2.7.
;Программа Лизы неполна, поскольку она не определила, как реализуется абстракция интервала.
;Вот определение конструктора интервала:
(define (make-interval a b) (cons a b))

;Завершите реализацию, определив селекторы upper-bound и lower-bound.
(define (upper-bound a) (cdr a))
(define (lower-bound a) (car a))

;Упражнение 2.8.
;Рассуждая в духе Лизы, опишите, как можно вычислить разность двух интервалов. Напишите
;соответствующую процедуру вычитания, называемую sub-interval.

(define (sub-interval x y)
  (let ((low-x (lower-bound x)) (low-y (lower-bound y)) (up-x (upper-bound x)) (up-y (upper-bound y)))
    (make-interval (- (max low-x low-y) (min low-x low-y)) (- (max up-x up-y) (min up-x up-y)))
    )
)

;Упражнение 2.9.
;Радиус (width) интервала определяется как половина расстояния между его верхней и нижней гра-
;ницами. Радиус является мерой неопределенности числа, которое обозначает интервал. Есть такие
;математические операции, для которых радиус результата зависит только от радиусов интервалов-
;аргументов, а есть такие, для которых радиус результата не является функцией радиусов аргу-
;ментов. Покажите, что радиус суммы (или разности) двух интервалов зависит только от радиусов
;интервалов, которые складываются (или вычитаются). Приведите примеры, которые показывают,
;что для умножения или деления это не так.

(define (radius p)
  (/ (- (upper-bound p) (lower-bound p))2)
)

;Упражнение 2.10.
;Бен Битобор, системный программист-эксперт, смотрит через плечо Лизы и замечает: неясно, что
;должно означать деление на интервал, пересекающий ноль. Модифицируйте код Лизы так, чтобы
;программа проверяла это условие и сообщала об ошибке, если оно возникает.

(define (div-interval x y)
  (if ( > ( * (upper-bound y)  (lower-bound y) ) 0 )
      (mul-interval x
                    (make-interval (/ 1.0 (upper-bound y))
                                   (/ 1.0 (lower-bound y))))
      (error "деление на интервал, пересекающий ноль, запрещено")
  )
)


;Упражнение 2.11.
;Проходя мимо, Бен делает туманное замечание: «Если проверять знаки концов интервалов, можно
;разбить mul-interval на девять случаев, из которых только в одном требуется более двух
;умножений». Перепишите эту процедуру в соответствии с предложением Бена.
(define (mul-interval x y)
 (let ((a1 (lower-bound x)) (b1 (lower-bound y)) (a2 (upper-bound x)) (b2 (upper-bound y)))
  (cond
   ((and (< a1 0) (< a2 0) (> b1 0) (> b2 0)) (make-interval (* a1 b2) (* a2 b1)))
   ((and (< a1 0) (< a2 0) (< b1 0) (> b2 0)) (make-interval (* a1 b2) (* a1 b1)))
   ((and (< a1 0) (< a2 0) (< b1 0) (< b2 0)) (make-interval (* a2 b2) (* a1 b1)))
   ((and (> a1 0) (> a2 0) (> b1 0) (> b2 0)) (make-interval (* a1 b1) (* a2 b2)))
   ((and (< a1 0) (> a2 0) (< b1 0) (< b2 0)) (make-interval (* a2 b1) (* a1 b1)))
   ((and (> a1 0) (> a2 0) (< b1 0) (> b2 0)) (make-interval (* a2 b1) (* a2 b2)))
   ((and (< a1 0) (> a2 0) (> b1 0) (> b2 0)) (make-interval (* a1 b2) (* a2 b2)))
   ((and (< a1 0) (> a2 0) (> b1 0) (> b2 0)) (make-interval (* a1 b2) (* a2 b2)))
   ((and (< a1 0) (> a2 0) (< b1 0) (> b2 0)) (make-interval (min (* a1 b2) (* b1 a2)) (max (* a2 b2) (* a1 b1))))
   (else  (make-interval (* a1 b2) (* a2 b1)))
  )
 )
 )
  

;Упражнение 2.12.
;Отладив программу, Лиза показывает ее потенциальному пользователю, а тот жалу-
;ется, что она решает не ту задачу. Ему нужна программа, которая работала бы с числами,
;представленными в виде срединного значения и аддитивной погрешности; например, ему
;хочется работать с интервалами вида 3.5±0.15, а не [3.35, 3.65]. Лиза возвращается к ра-
;боте и исправляет этот недочет, добавив дополнительный конструктор и дополнительные
;селекторы:
(define (make-center-width c w)
(make-interval (- c w) (+ c w)))
(define (center i)
(/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
(/ (- (upper-bound i) (lower-bound i)) 2))
;К сожалению, большая часть Лизиных пользователей — инженеры. В реальных техни-
;ческих задачах речь обычно идет об измерениях с небольшой погрешностью, которая
;измеряется как отношение радиуса интервала к его средней точке. Инженеры обыч-
;но указывают в параметрах устройств погрешность в процентах, как в спецификациях
;резисторов, которые мы привели в пример выше.
;Определите конструктор make-center-percent, который принимает среднее значение и по-
;грешность в процентах и выдает требуемый интервал. Нужно также определить селектор percent,
;который для данного интервала выдает погрешность в процентах. Селектор center остается тем
;же, что приведен выше.

(define (make-center-percent c pct)
  (let (( w (/(* c pct) 100)))
   (make-interval (- c w) (+ c w))
  )
)

(define (percent p)
  (* 100 (/ (width p) (center p)))
)