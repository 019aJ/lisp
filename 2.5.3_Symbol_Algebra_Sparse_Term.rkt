#lang racket
(require racket/include)
(require  "2.5.2_Coercion.rkt")
(require  "2.5.3_Symbol_Algebra_Term_Operations.rkt")
;Разреженные
(define (install-sparse-polynomial-package)
  ; внутренние процедуры
 (define (adjoin-term term term-list)
  (define (find-place upward-list below-list)
   (if (empty-termlist? below-list)
    (append upward-list (list term))
    (let ((input-order (order term)) (input-coef (coeff term)) (current-order (order (first-term term-list))) (current-coef (coeff (first-term term-list))))
     (cond
      ((= input-order current-order) (append upward-list (cons (make-term current-order (+ input-coef current-coef)) (cdr below-list))))
      ((> input-order current-order) (append upward-list (cons term (cdr below-list))))
      (else (find-place (append upward-list (list (car below-list))) (cdr  below-list)))
     )
    )
   )
  )
  (let ((term-order (order term)) (l-order (list-order term-list))) 
   (cond
    ((zero? (coeff term)) term-list)
    ((> term-order l-order ) (cons term term-list))
    (else (find-place '() term-list))
   )
  )
 )
 (define (list-order l)
  (if (null? l)
   0
   (order (first-term l))
  )
 )
 (define (the-empty-termlist) '())
 (define (first-term term-list) (car term-list))
 (define (rest-terms term-list) (cdr term-list))
 (define (empty-termlist? term-list) (null? term-list))
 (define (max-order term-list) (order (first-term term-list)))
 (define (sign-term L)
  (cond 
   ((empty-termlist? L) L)
   (else
    (let ((t1 (first-term L)) )
     (adjoin-term (make-term (order t1)(- 0 (coeff t1) )) (sign-term (rest-terms L)))
     )
    )
   )
  )
 
 (define (add-terms L1 L2)
  (cond 
   ((empty-termlist? L1) L2)
   ((empty-termlist? L2) L1)
   (else
    (let ((t1 (first-term L1)) (t2 (first-term L2)))
     (cond 
      ((> (order t1) (order t2)) (adjoin-term t1 (add-terms (rest-terms L1) L2)))
      ((< (order t1) (order t2)) (adjoin-term t2 (add-terms L1 (rest-terms L2))))
      (else (adjoin-term (make-term (order t1)(add (coeff t1) (coeff t2))) (add-terms (rest-terms L1) (rest-terms L2))))
     )
    )
   )
  )
 )
 (define (mul-terms L1 L2)
  (if (empty-termlist? L1)
   (the-empty-termlist)
   (add-terms (mul-term-by-all-terms (first-term L1) L2)(mul-terms (rest-terms L1) L2))
  )
 )
 (define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L)
   (the-empty-termlist)
   (let ((t2 (first-term L)))
    (adjoin-term (make-term (+ (order t1) (order t2))(mul (coeff t1) (coeff t2))) (mul-term-by-all-terms t1 (rest-terms L)))
   )
  )
 )
 
 (define (make-dense-termlist coefs) 
  (define (inner-dense source termlist)
   (if (null? source)
    termlist
    (inner-dense (cdr source) (append termlist (make-term (- (length source) 1) (car source))))
   )
  )
  (inner-dense coefs '())
 )
 (define (make-sparse-termlist termlist) 
  (define (inner-sparse source result)
   (if (null? source)
    result
    (inner-sparse (cdr source) (adjoin-term (car source) result ))
   )
  )
  (inner-sparse termlist '())
 )
  ; интерфейс к остальной системе

  (define (tag x) (attach-tag 'sparse x))
  (put 'the-empty-termlist 'sparse (tag (the-empty-termlist)))
  (put 'max-order '(sparse) max-order)
  (put 'first-term '(sparse) first-term)
  (put 'rest-terms '(sparse) rest-terms )
  (put 'empty-termlist? '(sparse) empty-termlist?)
  (put 'sign-term '(sparse) (lambda (x) (tag (sign-term x))))
  (put 'adjoin-term '(term sparse) (lambda (x y) (tag (adjoin-term x y))))
  (put 'add-terms '(sparse sparse) (lambda (x y) (tag (add-terms x y))))
  (put 'mul-terms '(sparse sparse) (lambda (x y) (tag (mul-terms x y))))
  (put 'make-from-dense-list 'sparse (lambda (x) (tag(make-sparse-termlist x))))
  (put 'make-from-sparse-list 'sparse (lambda (x) (tag(make-sparse-termlist x))))
)

(define (make-from-sparse-list l) ((get 'make-from-sparse-list 'sparse) l) )
(define (the-empty-termlist) (get 'the-empty-termlist 'sparse))

(install-sparse-polynomial-package)
(provide (all-defined-out))
