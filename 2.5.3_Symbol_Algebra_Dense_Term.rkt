#lang racket
(require racket/include)
(require  "2.5.2_Coercion.rkt")
(require  "2.5.3_Symbol_Algebra_Term_Operations.rkt")

;Плотные полиномы
(define (install-dense-polynomial-package)
  ; внутренние процедуры
 (define (adjoin-term term term-list)
  (define (find-place upward-list below-list)
   (let ((input-order (order term)) (input-coef (coeff term)) (current-order (max-order below-list)))
    (if (= input-order current-order)
     (append upward-list (cons (+ input-coef (car below-list)) (cdr below-list)))
     (find-place (append upward-list (list (car below-list))) (cdr  below-list))
    )
   )
  )
  (let ((input-order (order term)) (input-coef (coeff term)) (term-list-length (length term-list))) 
   (cond
    ((zero? (coeff term)) term-list)
    ((= input-order term-list-length) (cons (coeff term) term-list))
    ((> input-order term-list-length) (adjoin-term term (cons 0 term-list)))
    (else (find-place '() term-list))
   )
  )
 )
 (define (sign-term L)
  (cond 
   ((empty-termlist? L) L)
   (else (let ((t1 (first-term L)))
     (adjoin-term (make-term (order t1)(- 0 (coeff t1) )) (sign-term (rest-terms L)))
     )
    )
   )
  )
 (define (add-terms L1 L2)
  (cond 
   ((empty-termlist? L1) L2)
   ((empty-termlist? L2) L1)
   (else
    (let ((t1 (first-term L1)) (t2 (first-term L2)))
     (cond 
      ((> (order t1) (order t2)) (adjoin-term t1 (add-terms (rest-terms L1) L2)))
      ((< (order t1) (order t2)) (adjoin-term t2 (add-terms L1 (rest-terms L2))))
      (else (adjoin-term (make-term (order t1)(add (coeff t1) (coeff t2))) (add-terms (rest-terms L1) (rest-terms L2))))
     )
    )
   )
  )
 )
 (define (mul-terms L1 L2)
  (if (empty-termlist? L1)
   (the-empty-termlist)
   (add-terms (mul-term-by-all-terms (first-term L1) L2)(mul-terms (rest-terms L1) L2))
  )
 )
 (define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L)
   (the-empty-termlist)
   (let ((t2 (first-term L)))
    (adjoin-term (make-term (+ (order t1) (order t2))(mul (coeff t1) (coeff t2))) (mul-term-by-all-terms t1 (rest-terms L)))
   )
  )
 )
 (define (make-dense-termlist coefs) 
  (define (inner-dense source termlist)
   (if (null? source)
    termlist
    (inner-dense (cdr source) (append termlist (list (make-term (max-order source) (car source)))))
   )
  )
  (inner-dense coefs '())
 )
 (define (make-sparse-termlist termlist) 
  (define (inner-sparse source result)
   (if (null? source)
    result
    (inner-sparse (cdr source) (adjoin-term (car source) result ))
   )
  )
  (inner-sparse termlist '())
 )
 
 (define (the-empty-termlist) '())
 (define (max-order term-list) (- (length term-list) 1))
 (define (first-term term-list) (car term-list))
 (define (rest-terms term-list) (cdr term-list))
 (define (empty-termlist? term-list) (null? term-list))

  ; интерфейс к остальной системе

  (define (tag x) (attach-tag 'dense x))
  (put 'the-empty-termlist '(dense) the-empty-termlist)
  (put 'max-order '(dense) max-order)
  (put 'first-term '(dense) first-term)
  (put 'rest-terms '(dense) rest-terms)
  (put 'empty-termlist? '(dense) empty-termlist?)
  (put 'sign-term '(dense) (lambda (x) (tag (sign-term x))))
  (put 'adjoin-term '(term dense) (lambda (x y) (tag (adjoin-term x y))))
  (put 'add-terms '(dense dense) (lambda (x y) (tag (add-terms x y))))
  (put 'mul-terms '(dense dense) (lambda (x y) (tag (mul-terms x y))))
  (put 'make-from-dense-list 'dense (lambda (x) (tag(make-dense-termlist x))))
  (put 'make-from-sparse-list 'dense (lambda (x) (tag (make-sparse-termlist x))))
)

(install-dense-polynomial-package)
(provide (all-defined-out))

