#lang racket
(require racket/include)
(require  "2.5.2_Coercion.rkt")
(require  "2.5.3_Symbol_Algebra_Term_Operations.rkt")
(require  "2.5.3_Symbol_Algebra_Dense_Term.rkt")
(require  "2.5.3_Symbol_Algebra_Sparse_Term.rkt")
(require  "2.5.3_Symbol_Algebra_Term_Coercion.rkt")
(require  "2.5.3_Exercise_2.90_Symbol_Algebra.rkt")
;Упражнение 2.91.
;Многочлены с одной переменной можно делить друг на друга, получая частное и остаток
;Деление можно производить в столбик. А именно, разделим старший член делимого на старший член делителя. В результате получится первый терм частного. Затем умножим результат на
;делитель, вычтем получившийся многочлен из делимого и, рекурсивно деля разность на делитель,
;получим оставшуюся часть частного. Останавливаемся, когда порядок делителя превысит порядок делимого, и объявляем остатком то, что тогда будет называться делимым. Кроме того, если
;когда-нибудь делимое окажется нулем, возвращаем ноль в качестве и частного, и остатка
;Процедуру div-poly можно разработать, следуя образцу add-poly и mul-poly. Процедура
;проверяет, одна ли и та же у многочленов переменная. Если это так, div-poly откусывает
;переменную и передает задачу в div-terms, которая производит операцию деления над списками
;термов. Наконец, div-poly прикрепляет переменную к результату, который выдает div-terms.
;Удобно сделать так, чтобы div-terms выдавала и частное, и остаток при делении. Она может
;брать в качестве аргументов два терма и выдавать список, состоящий из списка термов частного
;и списка термов остатка.
;Закончите следующее определение div-terms, вставив недостающие выражения. Используйте ее, чтобы реализовать div-poly, которая получает в виде аргументов два экземпляра poly, а
;выдает список из poly–частного и poly–остатка.
(define (div-terms L1 L2)
  (if (empty-termlist? L1)
      (list (the-empty-termlist) (the-empty-termlist))
      (let ((t1 (first-term L1))
            (t2 (first-term L2)))
        (if (> (order t2) (order t1))
            (list (the-empty-termlist) L1)
            (let ((new-c (div (coeff t1) (coeff t2)))
                  (new-o (- (order t1) (order t2))))
              (let ((rest-of-result
                     ;рекурсивно вычислить оставшуюся часть результата
                     (div-terms ( - L1 (mul-terms (make-from-sparse-list (list (list new-o new-c))) L2)) L2)
                     ))
                ;сформировать окончательный результат
                ()
                )))))
)