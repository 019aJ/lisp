#lang racket
(require racket/include)
(require  "2.5.2_Coercion.rkt")

(define (install-polynomial-package)
 ;внутренние процедуры
 (define (add-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
   (make-poly (variable p1)(add-terms (term-list p1) (term-list p2)))
   (error "Многочлены от разных переменных -- ADD-POLY" (list p1 p2))
  )
 )
 (define (sub-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
   (make-poly (variable p1)(add-terms (term-list p1) (sign-term (term-list p2))))
   (error "Многочлены от разных переменных -- SUB-POLY" (list p1 p2))
  )
 )
 (define (mul-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
   (make-poly (variable p1) (mul-terms (term-list p1) (term-list p2)))
   (error "Многочлены от разных переменных -- MUL-POLY" (list p1 p2))
  )
 )
 (define (terms-zero? terms)
  (if (empty-termlist? terms)
   #t
   (and (zero? (coeff (first-term terms))) (terms-zero? (rest-terms terms)))
  )
 )
(define (poly-zero? p) (terms-zero? (term-list p)))
 ; представление poly
 (define (make-poly variable term-list)(cons variable term-list))
 (define (variable p) (car p))
 (define (term-list p) (cdr p))
 (define (variable? x) (symbol? x))
 (define (same-variable? v1 v2)(and (variable? v1) (variable? v2) (eq? v1 v2)))
 
 ; представление термов и списков термов
 (define (adjoin-term term term-list)
  (define (find-place upward-list below-list)
   (if (empty-termlist? below-list)
    (append upward-list (list term))
    (let ((input-order (order term)) (input-coef (coeff term)) (current-order (order (first-term term-list))) (current-coef (coeff (first-term term-list))))
     (cond
      ((= input-order current-order) (append upward-list (cons (make-term current-order (+ input-coef current-coef)) (cdr below-list))))
      ((> input-order current-order) (append upward-list (cons term (cdr below-list))))
      (else (find-place (append upward-list (list (car below-list))) (cdr  below-list)))
     )
    )
   )
  )
  (let ((term-order (order term)) (list-order (order (first-term term-list))) ) 
   (cond
    ((zero? (coeff term)) term-list)
    ((> term-order list-order ) (cons term term-list))
    (else (find-place '() term-list))
   )
  )
 )
 (define (the-empty-termlist) '())
 (define (first-term term-list) (car term-list))
 (define (rest-terms term-list) (cdr term-list))
 (define (empty-termlist? term-list) (null? term-list))
 (define (make-term order coeff) (list order coeff))
 (define (order term) (car term))
 (define (coeff term) (cadr term))
 (define (sign-term L)
  (cond 
   ((empty-termlist? L) L)
   (else
    (let ((t1 (first-term L)) )
     (adjoin-term (make-term (order t1)(- 0 (coeff t1) )) (sign-term (rest-terms L)))
     )
    )
   )
  )
 
 (define (add-terms L1 L2)
  (cond 
   ((empty-termlist? L1) L2)
   ((empty-termlist? L2) L1)
   (else
    (let ((t1 (first-term L1)) (t2 (first-term L2)))
     (cond 
      ((> (order t1) (order t2)) (adjoin-term t1 (add-terms (rest-terms L1) L2)))
      ((< (order t1) (order t2)) (adjoin-term t2 (add-terms L1 (rest-terms L2))))
      (else (adjoin-term (make-term (order t1)(add (coeff t1) (coeff t2))) (add-terms (rest-terms L1) (rest-terms L2))))
     )
    )
   )
  )
 )
 (define (mul-terms L1 L2)
  (if (empty-termlist? L1)
   (the-empty-termlist)
   (add-terms (mul-term-by-all-terms (first-term L1) L2)(mul-terms (rest-terms L1) L2))
  )
 )
 (define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L)
   (the-empty-termlist)
   (let ((t2 (first-term L)))
    (adjoin-term (make-term (+ (order t1) (order t2))(mul (coeff t1) (coeff t2))) (mul-term-by-all-terms t1 (rest-terms L)))
   )
  )
 )

 ;интерфейс к остальной системе
 (define (tag p) (attach-tag 'polynomial p))
 (put 'add '(polynomial polynomial)(lambda (p1 p2) (tag (add-poly p1 p2))))
 (put 'mul '(polynomial polynomial)(lambda (p1 p2) (tag (mul-poly p1 p2))))
 (put 'sub '(polynomial polynomial)(lambda (p1 p2) (tag (sub-poly p1 p2))))
 (put 'make 'polynomial (lambda (var terms) (tag (make-poly var terms))))
 (put 'make-term 'polynomial (lambda (order coef) (make-term order coef)))
 (put 'zero? '(polynomial) (lambda (p) (poly-zero? p)))
 (put 'sign '(polynomial) (lambda (p) (make-polynomial (variable p)(sign-term (term-list p)))))
 'done
)

(define (make-polynomial var terms)((get 'make 'polynomial) var terms))
(define (make-term order coef)((get 'make-term 'polynomial) order coef))
(define (sign p)(apply-generic 'sign p))
(install-polynomial-package)

(provide (all-defined-out))

